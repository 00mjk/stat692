---
title: "Linear Models"
author: "Douglas Bates"
date: "10/09/2014"
output: 
    ioslides_presentation:
        wide: true
        small: true
---
```{r preliminaries,echo=FALSE,results='hide'}
library(knitr)
library(ggplot2)
library(hexbin)
opts_chunk$set(cache=TRUE)
options(width=100)
```

# Simple linear regression

## The brain-weight data

A famous data set from a 1976 _Science_ paper provides average body weight (kg) and brain weight (g) for 62 species of mammals.
```{r brains}
data("brains",package="alr4")
str(brains)
head(brains)
```

## Initial plots
```{r p1,fig.align='center'}
p <- ggplot(brains,aes(x=BodyWt,y=BrainWt)) + xlab("Average body weight (kg)") + ylab("Average brain weight (g)")
(p <- p + geom_point())
```

## On a log-log scale
```{r log-log,fig.align='center'}
(p <- p + scale_x_log10() + scale_y_log10())
```

## With a smoother line
```{r smoother,fig.align='center',echo=FALSE,warning=FALSE}
p + geom_smooth()
```

## With a regression line
```{r regr,fig.align='center',echo=FALSE}
p + geom_smooth(method="lm")
```

# Fitting a simple linear regression

## Calling `lm`

- As with other model-fitting functions in `R`, the first argument to `lm` is a formula.
- The second, optional but recommended, argument is `data` which is a data frame in which to evaluate the expressions in the formula
    + it may seem handy to omit it and use variables from the GlobalNameSpace but you lose the audit trail when you do this
    
```{r fm1}
(fm1 <- lm(log(BrainWt) ~ 1 + log(BodyWt), brains))
```

## The `summary` is more than the object

A peculiarity of the terminology in `R` model fitting is that `print`ing a fitted model provided minimal information but applying `summary` to it provides much more.
```{r summaryfm1}
summary(fm1)
```

## Suppressing "significance stars"
- One of the worst decisions in `R` development was adding "significance stars" to the `summary` output for many models.
- They are optional.  Unfortunately, the default is to have them.
```{r signifstars,cache=FALSE}
options(show.signif.stars=FALSE)
summary(fm1)
```

## The model matrix

- the terminology used in `R` is that the formula and the data together generate a `model matrix`
- sometimes the term `design matrix` is used.  `model matrix` is more accurate
```{r mm}
head(mm1 <- model.matrix(fm1))
str(mm1)
```

## The Intercept term

- Many "statistical packages" assume that an intercept will be included in a model.
- I prefer to indicate the intercept explicitly by writing the formula as `1 + BodyWt`
- To suppress the intercept you must write the formula as `0 + BodyWt`
- The intercept term generates the initial column of 1's in the model matrix
```{r ones}
all(mm1[,1] == 1)
```

## Extracting the coefficient summary

- Sometimes you just want the coefficient table from the summary, which is available as
```{r coef}
(ctbl <- coef(summary(fm1)))
```
- There is a special method for printing tables with p-values in them.  It is used in `print.summary.lm` but not in the more terse form used above.
- Because the special printing method shows `< 2e-16` for small p-values, some people believe that probabilities lower than that are not evaluated.  This is not the case.

## Plots of an `lm` object

- There are several "pre-packaged" plots for `lm` objects.  A total of 6 are available.
```{r plot1,fig.align='center'}
plot(fm1,which=1)
```

## plot 2
```{r plot2,fig.align='center',echo=FALSE}
plot(fm1,which=2)
```

## plot 3
```{r plot3,fig.align='center',echo=FALSE}
plot(fm1,which=3)
```

## plot 4
```{r plot4,fig.align='center',echo=FALSE}
plot(fm1,which=4)
```

## plot 5
```{r plot5,fig.align='center',echo=FALSE}
plot(fm1,which=5)
```

## plot 6
```{r plot6,fig.align='center',echo=FALSE}
plot(fm1,which=6)
```

## Methods for `lm` object

Most model-fitting functions assign a "class" tag to the return value
```{r classlm}
class(fm1)
```
allowing for "generic" functions to have special methods used with such objects.

The `methods` function provides a list of methods for a given generic or for a given class.
```{r methods}
methods(class=class(fm1))
```

## Using extractor functions
- Many of the methods for `lm` objects are "extractor" functions.  That it, they extract some information from the fitted model in a way that does not depend on the internal structure.
- Try to use such functions whenever possible so as to "future proof" your code.
- When writing code for your own model fitting, provide extractors when possible
```{r coeff}
coef(fm1)      # estimates of the coefficients
deviance(fm1)  # residual sum of squares
logLik(fm1)    # log-likelihood
```

## More extractors

```{r extractors}
vcov(fm1)      # estimated variance-covariance of coefficient estimators
anova(fm1)     # analysis of variance table (trivial in this case)
```

## Even more extractors

```{r confint}
confint(fm1)   # confidence intervals on the coefficients
df.residual(fm1) # degrees of freedom for residuals
nobs(fm1)      # number of observations used to fit the model
formula(fm1)   # formula for the model matrix
```

## Fitted values

```{r residuals}
fitted(fm1)
```

## Residuals (raw)

- weighted residuals are available as `residuals(fm1,type = "pearson")` or as `weighted.residuals(fm1)`
```{r rawresiduals}
unname(residuals(fm1))  # suppress printing of names
```

## Various kinds of cooked residuals

- other generics provide the "studentized" residuals, `rstudent`, and the standardized residuals
```{r studentized}
unname(rstudent(fm1))
```

# Numerical methods, including simulation

## Simulating responses from a fitted model

- For generality the `simulate` generic returns a `data.frame` of simulated responses
```{r strsimulate}
str(simulate(fm1,nsim=10L))
```

## Conversion to a matrix
```{r datamatrix}
str(yy <- data.matrix(simulate(fm1,nsim=10000L)))
```
- It is very slow to fit the simulated responses in a loop calling `lm`
- The response in a call to `lm` can be a matrix.
```{r multipleRHS}
system.time(fms <- lm(yy ~ 1 + log(BodyWt),brains))
str(cc <- coef(fms))
```

## Coefficients from simulated data
```{r plot,echo=FALSE}
ccf <- unname(as.data.frame(t(cc)))
names(ccf) <- c("Intercept","logBodyWt")
qplot(Intercept,logBodyWt,data=ccf,geom="hex")
```


## `qr` and `effects`

```{r qr}
str(qr(fm1))
```

- Objects of class `qr` represent an orthogonal-triangular or QR decomposition of a matrix

```{r effects}
str(ee <- effects(fm1))
```
